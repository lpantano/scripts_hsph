---
title: "mirna as predictor of HIV"
author: "Lorena Pantano"
date: "09/15/2014"
output:
  knitrBootstrap::bootstrap_document:
    theme: readable
    highlight: zenburn
    theme.chooser: TRUE
    highlight.chooser: TRUE
  html_document:
    highlight: zenburn

---

```{r setup}
library(knitr)
library(rmarkdown)
library(knitrBootstrap)
library(ggplot2)
library(reshape)
library(dplyr)
library(edgeR)
library(DESeq2)
library(RUVSeq)
library(limma)
library(genefilter)
library(CHBUtils)
library(NMF)
library(dendextend)
library(pscl)
library(gtools)
library(seqinr)
library(gridExtra)
library(scde)
library(dendextend)
theme_set(theme_bw())
root_path<-"~/repos/pipelines/fichorova_mirna"
dn <- "fichorova_mirna"
```

```{r render,eval=FALSE}
opts_chunk$set(tidy=TRUE, highlight=T, figalign="center",cache=F,
               fig.height=6, fig.width=9, message=F, error=F, warning=F, bootstrap.show.code=FALSE)
source("~/repos/myRfunctions/transactions.R")
#render_2_drop("~/repos/pipelines/fichorova_mirna/reports/mirna.rmd",dn)
```


```{r load}
setwd(root_path)
counts = read.table(paste0(root_path, "/fichorova_mirna.csv"), header=T, row.names = 1, sep="\t")
metadata = read.table(paste0(root_path, "/metadata.csv"), header=T, row.names = 1, sep="\t", stringsAsFactors = F)
metadata[is.na(metadata)] = "None"
row.names(metadata) = names(counts)
counts = counts[ ,grepl("Exosome",metadata$SampleID) ]
metadata = metadata[ grepl("Exosome",metadata$SampleID), ]
metadata$pato = c("None","PB","Normal","Normal","Activator","None","Activator","PB","PB_activator","TV","Normal","None","AV")
```


# Results


### Average expression


```{r raw-data}
type = as.character( row.names(counts) )
type[ grepl("miR", type) ] = "miR"
type[ grepl("let", type) ] = "miR"
type[ grepl("HK_", row.names(counts) ) ] = "HK"
type[ grepl("ANT", row.names(counts) ) ] = "NEG"
type[ grepl("POS", row.names(counts) ) ] = "POS"



dd = melt(cbind(counts, type))
dd$exp = metadata[ dd$variable, 2 ]
ggplot( dd, aes(y=log2(value+1),x=variable, fill=exp) ) +
    geom_boxplot()+
    theme_bw() +
    facet_wrap(~type) 
    
```

It seems positive controls are quite similar. No problems in the technology itself.

And negative controls show no technology noise.

### Total counts detected

```{r raw-total}
dd = dd %>% group_by(type,variable,exp) %>%
     summarise(total=sum(value))
ggplot( dd, aes(y=total, x=variable, fill= exp) ) +
    geom_bar( stat = 'identity', position = "dodge" ) +
    theme_bw() +
    scale_fill_brewer( palette = "Set1" )+
    facet_wrap(~type)
```

There are some samples with low number of counts compared to others, that will 
affect the comparison because non_seen miRNAs are difficult to predict as 
expressed or not expressed.


### cumulative curve

This helps to see if the complexity of miRNA detected in all samples is similar. 
Each sample is sorted in decreasing expression values. At each point the values of all previous
miRNAs are added up. The idea is to see at which number of miRNAs we see data 
saturation.

```{r raw-cumulative}
dd = data.frame()
for (i in 1:ncol(counts)){
    y = cumsum( sort(counts[grepl("miR",type),i], decreasing = T) )[1:100]
    dd = rbind(dd, data.frame(y=y, rank = 1:length(y) , sample = i, exp = metadata$Expcode[i]))
}


ggplot( dd, aes(y=y, x=rank, colour= as.factor(sample)) ) +
    geom_point() +
    theme_bw() +
    scale_fill_brewer( palette = "Set1" )


```

It is quite diverse. And it looks like only around 15 miRNAs are the ones that explain
all the data.

The same plot but with percentages of total data.

```{r raw-cum-percentage}
dd = data.frame()
for (i in 1:ncol(counts)){
    y = cumsum( sort(counts[grepl("miR",type),i], decreasing = T) )[1:100] / sum(counts[,i])
    dd = rbind(dd, data.frame(y=y, rank = 1:length(y) , sample = i, exp = metadata$Expcode[i]))
}


ggplot( dd, aes(y=y, x=rank, colour= as.factor(sample)) ) +
    geom_point() +
    theme_bw() +
    scale_fill_brewer( palette = "Set1" ) +
    labs(list(y="% of data"))

```



## Normalize by library size

```{r norm}
dge <- DGEList(counts=counts)
dge <- calcNormFactors(dge)
cpm = cpm(dge,lib.size = T,log = T)
dd = melt( as.data.frame(cbind(cpm, type)), id.vars = "type" )
dd$exp = metadata[ dd$variable, 2 ]
dd$value = as.numeric(as.character(dd$value))
ggplot( dd, aes(y=value,x=variable, fill=exp) ) +
    geom_boxplot()+
    theme_bw() +
    facet_wrap(~type) 

```


### positive mirnas and quantile 60%

It helps to see the positive probes expression and the lowest expressed
miRNA in case

```{r q20}
q60 <- apply(counts[type=="miR",],2,quantile,.60)
pos_values <- colMeans(counts[type=="POS",])

ggplot(data.frame(values=c(q60,pos_values), measure=c(rep("q60",length(q60)),
                                                      rep("positive",length(pos_values))
                                                      )
                  ))+
                      geom_jitter(aes(y=values,x=measure))

```

I think there is no background noise, so I will keep any miRNA with more than 5
counts in average? (some groups only have 1 sample, avoiding to remove miRNAs
only expressed in more than X samples)

### filtering

I will keep only miRNAs that have a good expression, like average expression more than > 5 counts.

```{r keep}
keep <- apply(counts[type=="miR" | type=="POS",],1, function(x){
    mean(x) >= 5
})

counts_filter = counts[ type == "miR" | type == "POS",][keep,]
```

Getting after that `r sum(keep)` miRNAs.

```{r norm-filter}
dge <- DGEList(counts=counts_filter)
dge <- calcNormFactors(dge)
cpm = cpm(dge,lib.size = T,log = T)

type = as.character( row.names(cpm) )
type[ grepl("miR-", type) ] = "miR"
type[ grepl("let-", type) ] = "miR"
type[ grepl("HK_", type) ] = "HK"
type[ grepl("ANT", type ) ] = "NEG"
type[ grepl("POS", type ) ] = "POS"

dd = melt( as.data.frame(cbind(cpm, type)), id.vars = "type" )
dd$exp = metadata[ dd$variable, 2 ]
dd$value = as.numeric(as.character(dd$value))
ggplot( dd, aes(y=value,x=variable, fill=exp) ) +
    geom_boxplot()+
    theme_bw() +
    facet_wrap(~type) 

```

## Normalization by positive control 

In addition to library size, we will normalize using the positive controls as well.
I will use RUVseq package. With this will get a factor that should help to make
samples equal. At least, to remove noise coming from technical problems.

```{r ruv-neg}

controls = row.names(counts_filter)[type=="POS"]
set = newSeqExpressionSet(as.matrix(counts_filter), phenoData = metadata[,c(1,2)])
set_norm = RUVg(set, controls, k=1)

```


### Expression after normalization

```{r after-ruv}
#dge_ruv <- DGEList(counts=set_norm@)
#dge_ruv <- calcNormFactors(dge_ruv)
#cpm_ruv = cpm(dge_ruv,lib.size = T, log = T)
cpm_ruv = log2(set_norm@assayData$normalizedCounts+1)
    
dd = melt( as.data.frame(cbind(cpm_ruv, type)), id.vars = "type" )
dd$exp = metadata[ dd$variable, 2 ]
dd$value = as.numeric(as.character(dd$value))
ggplot( dd, aes(y=value,x=variable, fill=exp) ) +
    geom_boxplot()+
    theme_bw() +
    facet_wrap(~type) 

```


It seems good enough to try to do some comparison samples.


There is a correlation among library_size and the factor extracted by RUVseq.

```{r ruv-w-cor}
dd = data.frame( weight = set_norm@phenoData@data$W_1,
                 library_size = colSums(counts_filter) )
ggplot(dd, aes(weight, library_size)) + 
    geom_point()
```


### clustering

```{r mds}
cpm_ruv = cpm_ruv[type=="miR",]
mds(cpm_ruv, condition = metadata$Expcode,xi = 1, yi = 2,d = "cor") +
    scale_color_brewer(palette = "Set1")
mds(cpm_ruv, condition = metadata$pato,xi = 1, yi = 2,d = "cor") +
    scale_color_brewer(palette = "Set1")
```

### heatmap with highest variable miRNAS

```{r lower}
cv <- apply(cpm_ruv,1,function(x){
    sd(x)/mean(x)
})

max.cv <- names(head(sort(cv,decreasing = T),30))
max.exp = names(head( sort(rowMeans(cpm_ruv), decreasing = T),50))
```

Heatmap using the most variable miRNAs


```{r heatmap}
cols1 = brewer.pal(9,"Set1")
cols2 = brewer.pal(9,"Set3")
aheatmap( cpm_ruv[max.cv,], annCol = metadata[,c(2,4)], annLegend = TRUE,distfun = function(x){dist(x)^2},hclustfun="ward",annColors = list(Expcode=cols1,pato=cols2), labRow  = row.names(cpm_ruv[max.cv,]) )
```


## DEG

I removed sample number 2 since we have been told it was frozen long period.
It is shown the miRNAs sorted by p-value/p-adjust value (top 20). 
In those comparison when only on sample in the group the power 
to detect real de-regulation is low.

* logFC: is the log2 fold change 
* adj.PVal: is the adjusted pvalue after correcting for multiple testing


### med versus L. crispatus    

10, 19 versus 4,18

```{r de-Lc, results='asis'}
dge <- DGEList(counts=counts_filter[,-1])
dge <- calcNormFactors(dge)
cpm = cpm(dge,lib.size = T,log = T)
group = make.names( sub( " ","", sub("_","",metadata[-1,2]) ) )
d.sva <- model.matrix(~ set_norm@phenoData@data$W_1[-1] + group)
colnames(d.sva)[2] = "ruv"
colnames(d.sva) = sub("group","",colnames(d.sva))
v.sva <- voom(dge,d.sva,plot = TRUE)
fit.sva<-lmFit(v.sva)
contrast = makeContrasts(LactobacillusCrispatus-mediumNoBacteria,levels=d.sva)
fit1 = contrasts.fit(fit.sva, contrast)
fit1<-eBayes(fit1)
whole_table <- topTable(fit1, number = nrow(v.sva$E), )
files = "lcrispatusVSmedium.txt"
write.table(whole_table, files, sep="\t")
knitr::kable(head(whole_table,20))

```


### med versius prevotella    

10, 19, versus 3, 12

```{r de-Lp, results='asis'}
contrast = makeContrasts(PrevotellaBivia-mediumNoBacteria,levels=d.sva)
fit1 = contrasts.fit(fit.sva, contrast)
fit1<-eBayes(fit1)
whole_table <- topTable(fit1, number = nrow(v.sva$E) )
files = c("vprevotellaVSmedium.txt",files)
write.table(whole_table, files[1], sep="\t")
knitr::kable(head(whole_table,20))
```

### med versus malp    

10, 19 versus 11 


```{r de-malp, results='asis'}
contrast = makeContrasts(MALP.2-mediumNoBacteria,levels=d.sva)
fit1 = contrasts.fit(fit.sva, contrast)
fit1<-eBayes(fit1)
whole_table <- topTable(fit1, number = nrow(v.sva$E) )
files = c("malpVSmedium.txt",files)
write.table(whole_table[,1:2], files[1], sep="\t")
knitr::kable(head(whole_table[,1:2],20))
```


### LactobacillusCrispatus vs Av    

18, 4 versus 20 

```{r de-Lc-Av, results='asis'}
fit1<-eBayes(fit.sva)
whole_table <- topTable(fit1, coef = "LactobacillusCrispatus",number = nrow(v.sva$E) )
files = c("lcrispatusVSav.txt",files)
write.table(whole_table[,1:2], files[1], sep="\t")
knitr::kable(head(whole_table[,1:2],20))
```


### LactobacillusGasseri vs Av    

5 versus 20 

```{r de-Lg-Av, results='asis'}
fit1<-eBayes(fit.sva)
whole_table <- topTable(fit1, coef = "LactobacillusGasseri",number = nrow(v.sva$E) )
files = c("lgasseriVSav.txt",files)
write.table(whole_table[,1:2], files[1], sep="\t")
knitr::kable(head(whole_table[,1:2],20))
```

### Tvaginalis_virus vs medium

17 versus 19, 10

```{r de-Tv, results='asis'}
contrast = makeContrasts(Tvaginalisvirus-mediumNoBacteria,levels=d.sva)
fit1 = contrasts.fit(fit.sva, contrast)
fit1<-eBayes(fit1)
whole_table <- topTable(fit1, number = nrow(v.sva$E) )
files = c("tvaginalis_virusVSmedium.txt",files)
write.table(whole_table[,1:2], files[1], sep="\t")
knitr::kable(head(whole_table[,1:2],20))
```

### Files

```{r files, results='asis'}
    f = lapply(files, function(x){
        data.frame( 
                   download  = paste0("<a href=",x,">",x,"<a/></br>"))
        
    })

void = copy_batch_2_drop("txt",dn)

knitr::kable(do.call(rbind, f))
```

### figures

```{r heatmap-for-grant}
cv <- apply(cpm_ruv,1,function(x){
    sd(x)/mean(x)
})
max.cv <- names(head(sort(cv,decreasing = T),25))
aheatmap( cpm_ruv[max.cv,-10], annCol = metadata[-10,c(4),drop=FALSE], annLegend = TRUE,hclustfun="ward",annColors = list(Group=cols1),labCol="", labRow  = row.names(cpm_ruv[max.cv,]),fontsize = 11, cexRow = 2 )

new_count = cpm_ruv[max.cv,c("X5","X7","X11","X15","X20")]
#2 19 10
new_count=cbind(new_count,data.frame(nomedium=rowMeans(cpm_ruv[max.cv,c("X2","X19","X10")])))
#4 18 
new_count=cbind(new_count,data.frame(lc=rowMeans(cpm_ruv[max.cv,c("X18","X4")])))
#3 12
new_count=cbind(new_count,data.frame(pb=rowMeans(cpm_ruv[max.cv,c("X3","X12")])))

meta = metadata[c("X5","X7","X11","X15","X20","X2","X4","X3"),]

meta[,4] = factor(meta[,4],levels=c("A. vaginae","P. bivia", "P. bivia with poly(I:C)","poly(I:C)","L. crispatus", "L. gasseri",
                                     "No bacteria", "MALP-2"))
aheatmap( new_count, annCol = meta[,c(4),drop=FALSE], annLegend = TRUE, distfun = function(x){dist(x)^2}, hclustfun="ward",annColors = list(Group=cols1),labCol= NA, labRow  = row.names(cpm_ruv[max.cv,]),fontsize = 11, cexRow = 2 )



```

